a2保存13

通过查看asm文件，我发现函数g被内联f函数，f函数被内联到main函数，所以没有对f,g的调用。main函数中printf 中包含了一个对 f 的调用。

0000000000000628

0x38

首先，57616 转换为 16 进制为 e110，所以格式化描述符 %x 打印出了它的 16 进制值。其次，如果在小端（little-endian）处理器中，数据0x00646c72 的高字节存储在内存的高位，那么从内存低位，也就是低字节开始读取，对应的 ASCII 字符为 rld。如果在 大端（big-endian）处理器中，数据 0x00646c72 的高字节存储在内存的低位，那么从内存低位，也就是高字节开始读取其 ASCII 码为 dlr。所以如果大端序和小端序输出相同的内容 i ，那么在其为大端序的时候，i 的值应该为 0x726c64，这样才能保证从内存低位读取时的输出为 rld 。无论 57616 在大端序还是小端序，它的二进制值都为 e110 。大端序和小端序只是改变了多字节数据在内存中的存放方式，并不改变其真正的值的大小，所以 57616 始终打印为二进制 e110 。

函数参数是通过寄存器a1、a2等传递的。如果printf函数少传递一个参数，它仍然会从一个确定的寄存器中读取所需的参数值。然而，由于我们没有提供这个确定的参数并将其存储在寄存器中，函数将从该寄存器中获取一个随机且不确定的值作为参数。因此，在这个例子中，我们无法确定y=后面的值是什么。